package com.example.lostandfound.services;

import com.example.lostandfound.model.Found_items;
import com.example.lostandfound.model.Lost_items;
import com.example.lostandfound.model.Match_history;
import com.example.lostandfound.repository.FoundItemRepository;
import com.example.lostandfound.repository.LostItemRepository;
import com.example.lostandfound.repository.MatchingHistoryRepository;
import org.springframework.stereotype.Service;
import org.apache.commons.text.similarity.LevenshteinDistance;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class MatchingServices {

    private final LostItemRepository lostRepo;
    private final FoundItemRepository foundRepo;
    private final MatchingHistoryRepository matchHistoryRepo;
    private final NotificationService notificationService;
    private final AIService aiService;

    public MatchingServices(LostItemRepository lostRepo,
                            FoundItemRepository foundRepo,
                            MatchingHistoryRepository matchHistoryRepo,
                            NotificationService notificationService,
                            AIService aiService) {
        this.lostRepo = lostRepo;
        this.foundRepo = foundRepo;
        this.matchHistoryRepo = matchHistoryRepo;
        this.notificationService = notificationService;
        this.aiService = aiService;
    }

    // Fuzzy name match
    private boolean isNameSimilar(String name1, String name2) {
        if (name1 == null || name2 == null) return false;
        name1 = name1.toLowerCase();
        name2 = name2.toLowerCase();
        int distance = LevenshteinDistance.getDefaultInstance().apply(name1, name2);
        int maxLen = Math.max(name1.length(), name2.length());
        return ((double) distance / maxLen) <= 0.3; // <=30% difference
    }

    // Fuzzy description match
    private boolean isDescriptionSimilar(String d1, String d2) {
        if (d1 == null || d2 == null) return false;
        d1 = d1.toLowerCase();
        d2 = d2.toLowerCase();
        int distance = LevenshteinDistance.getDefaultInstance().apply(d1, d2);
        int maxLen = Math.max(d1.length(), d2.length());
        return ((double) distance / maxLen) <= 0.4; // a bit looser for descriptions
    }
    private int hamdis(String h1, String h2)
    {
    	int dis=0;
    	int len= Math.min(h1.length(),h2.length());
    	for(int i=0;i<len;i++) {
    		if(h1.charAt(i)!=h2.charAt(i))
    			dis++;
    	}
    	return dis+ Math.abs(h1.length()-h2.length());
    }

    // AI-based image similarity
    private boolean isImageSimilar(Found_items found, Lost_items lost) {
        if (found.getImageEmbedding()!= null && lost.getImageEmbedding() != null) { 
        float[] vec1 = aiService.getImageEmbedding(found.getImageUrl());
        float[] vec2 = aiService.getImageEmbedding(lost.getImageUrl());
        double similarity = aiService.cosineSimilarity(vec1, vec2);
        return similarity >= 0.85;}
        if(found.getImageHash()!=null && lost.getImageHash()!=null)
        {
        	int distance= hamdis(found.getImageHash(), lost.getImageHash());
        	return distance <=8;
        }
        return false;
    }

    // Match lost → found
    public List<Found_items> findMatchesForLost(Lost_items lost) {
        List<Found_items> allFound = foundRepo.findAll();

        List<Found_items> matches = allFound.stream()
        		.filter(f -> {
                    boolean nameMatch = isNameSimilar(f.getItemName(), lost.getItemName());
                    boolean descMatch = isDescriptionSimilar(f.getDescription(), lost.getDescription());
                    boolean imageMatch = isImageSimilar(f, lost);

                    // must match name & description, or match images (or missing images)
                    boolean basicMatch = (nameMatch && descMatch);
                    boolean imageCondition = imageMatch || lost.getImageUrl() == null || f.getImageUrl() == null;

                    // location must match
                    return (basicMatch || imageCondition) && f.getLocation().equalsIgnoreCase(lost.getLocation());
                })
                .collect(Collectors.toList());

        
        for (Found_items found : matches) {
            Match_history match = new Match_history();
            match.setLostItem(lost);
            match.setFoundItem(found);
            match.setLostContact(lost.getEmail());
            match.setFoundContact(found.getEmail());
            matchHistoryRepo.save(match);
            // Send notifications via email
            String subject = "Lost & Found Match Found!";
            String lostMsg = "Hello! Your lost item '" + lost.getItemName() + "' matches a found item. Contact: " + found.getEmail();
            String foundMsg = "Hello! Your found item '" + found.getItemName() + "' matches a lost item. Contact: " + lost.getEmail();

            notificationService.sendEmail(lost.getEmail(), subject, lostMsg);
            notificationService.sendEmail(found.getEmail(), subject, foundMsg);
        }
        return matches;
    }

    // Match found → lost
    public List<Lost_items> findMatchesForFound(Found_items found) {
        List<Lost_items> allLost = lostRepo.findAll();

        List<Lost_items> matches = allLost.stream()
            .filter(l -> {
                boolean nameMatch = isNameSimilar(l.getItemName(), found.getItemName());
                boolean descMatch = isDescriptionSimilar(l.getDescription(), found.getDescription());
                boolean imageMatch = isImageSimilar(found,l);

                boolean basicMatch = (nameMatch && descMatch);
                boolean imageCondition = imageMatch || found.getImageUrl() == null || l.getImageUrl() == null;

                // location must match
                return (basicMatch || imageCondition) && l.getLocation().equalsIgnoreCase(found.getLocation());
            })
            .collect(Collectors.toList());

        for (Lost_items lost : matches) {
            Match_history match = new Match_history();
            match.setLostItem(lost);
            match.setFoundItem(found);
            match.setLostContact(lost.getEmail());
            match.setFoundContact(found.getEmail());
            matchHistoryRepo.save(match);
            // Send notifications via email
            String subject = "Lost & Found Match Found!";
            String lostMsg = "Hello! Your lost item '" + lost.getItemName() + "' matches a found item. Contact: " + found.getEmail();
            String foundMsg = "Hello! Your found item '" + found.getItemName() + "' matches a lost item. Contact: " + lost.getEmail();

            notificationService.sendEmail(lost.getEmail(), subject, lostMsg);
            notificationService.sendEmail(found.getEmail(), subject, foundMsg);
        }
        return matches;
    }
}
